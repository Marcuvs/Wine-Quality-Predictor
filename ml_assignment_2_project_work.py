# -*- coding: utf-8 -*-
"""ML assignment 2: Project work

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IC0KlVbI-rTA8e08CKIUskAmz3BCWdg0
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sklearn as sk
import gradio as gr
import seaborn as sns
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import MinMaxScaler

# Citation: Cortez, P., Cerdeira, A., Almeida, F., Matos, T., & Reis, J. (2009). Wine Quality [Dataset]. UCI Machine Learning Repository. https://doi.org/10.24432/C56S3T.

!pip3 install -U ucimlrepo

from ucimlrepo import fetch_ucirepo

# Fetch dataset
wine_quality = fetch_ucirepo(id=186)

# data (as pandas dataframes)
X = wine_quality.data.features.drop(columns=['fixed_acidity']).drop(columns=['density']).drop(columns=['citric_acid']).drop(columns=['total_sulfur_dioxide'])
y = wine_quality.data.targets

# variable information
print(wine_quality.variables)
print(X)

X_train, X_test, y_train, y_test = sk.model_selection.train_test_split(X, y, test_size=0.2, random_state=42)

reg = sk.linear_model.LinearRegression()
boost = sk.ensemble.AdaBoostRegressor(random_state=1)
gradboost = sk.ensemble.HistGradientBoostingRegressor(random_state=1)
hobo = sk.ensemble.BaggingRegressor(random_state=1)
forest = sk.ensemble.RandomForestRegressor(n_estimators=100, random_state=1)
stack = sk.ensemble.StackingRegressor(estimators=[('reg', reg), ('boost', boost), ('gradboost', gradboost), ('hobo', hobo), ('forest', forest)])
voting = sk.ensemble.VotingRegressor([('reg', reg), ('boost', boost), ('gradboost', gradboost), ('hobo', hobo), ('forest', forest)])
models = [reg,
          boost,
          gradboost,
          hobo,
          forest,
          stack,
          voting
          ]

for i in range(len(models)):
  models[i].fit(X_train, y_train.values.ravel())

  # round to whole numbers.
  prediction = np.round(models[i].predict(X_test)).astype(int)
  # limit for numbers 1..10.
  prediction = np.clip(prediction, 0, 10)

  print(f'{models[i]} : ')
  print(f'Accuracy: {accuracy_score(y_test, prediction)}')
  print(f'Precision: {precision_score(y_test, prediction, average="weighted", zero_division=0)}')
  print(f'Recall: {recall_score(y_test, prediction, average="weighted", zero_division=0)}')
  print(f'F1-score: {f1_score(y_test, prediction, average="weighted", zero_division=0)}')
  print() # spacing

# Creating a graph to show importance in the RandomForestRegressor
importance = forest.feature_importances_
plt.figure(figsize=(10, 6))
plt.bar(X.columns, importance)
plt.xlabel("Features")
plt.ylabel("Importance Value")
plt.title("Importance of different features")
plt.xticks(rotation=60)
plt.show()
print(X.columns)

"""Since RandomForestRegressor seems to have the best results, I'll pick it as the one I'll use in the gradio webside.

It seems to have an accuracy and recall of about 66.1% (They seem to be the same?), precision of 66.9% and an F1-score of 64.6%. Overall the highest of any ensemble method tested.
"""

def predict_quality(volatile_acidity, residual_sugar, chlorides, free_sulfur_dioxide, pH, sulphates, alcohol):
    return np.round(forest.predict([[volatile_acidity, residual_sugar, chlorides, free_sulfur_dioxide, pH, sulphates, alcohol]])[0]).astype(int)

with gr.Blocks() as demo:
  gr.Markdown("# Welcome to the Wine Quality Predictor!")
  gr.Markdown("""
      This application predicts wine quality based on various chemical properties.
      Please fil in the following information to get a wine quality prediction that is correct roughly 70% of the time.
      """)
  inputs = [gr.Number(label="volatile_acidity"),
            gr.Number(label="residual_sugar"),
            gr.Number(label="chlorides"),
            gr.Number(label="free_sulfur_dioxide"),
            gr.Number(label="pH"),
            gr.Number(label="sulphates"),
            gr.Number(label="alcohol")]
  outputs = gr.Number(label="Predicted Quality")
  submit_btn = gr.Button("Submit")
  submit_btn.click(fn=predict_quality, inputs=inputs, outputs=outputs)

demo.launch(share=True)

